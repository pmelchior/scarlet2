initial_template: "import scarlet2\n{{imports}}\n\n{{code}}"
feedback_url: "https://docs.google.com/forms/d/e/1FAIpQLScKHbiqxhizacgzRx3xHEdqqjgtZBsxjtQZFJlYBdLcbOnfBg/viewform"
questions:
  - question: Do you have a single image, or multiple images?
    answers:
      - answer: Single image
        tooltip: A single image to model
        templates:
          - replacement: code
            code: "channels=[\"g\", \"r\", \"i\", \"z\", \"y\"]\n\n{{obs}}"
        commentary: "We start with initializing the channels for the observation. The channels in the image can be specified as a list of the filters, like the above example."
      - answer: Multiple images
        tooltip: A single image to model
        followups:
          - question: Do you wish to model transient or variable sources across multiple epochs?
            variable: "transient"
            answers:
              - answer: "Yes"
                templates:
                  - replacement: code
                    code: "channels=[(\"g\",0)]
                           \nchannels=[(\"g\",1)]
                           \n\n{{obs}}"
                commentary: "For each image, the channels should be a list of tuples where each tuple provides the filter and an epoch identifier which is unique for each image of a particular filter. For example, you might have two g-band images from different times, which would be initialized separately with `channels=[(‘g’,0)]` and `channels=[(‘g’,1’)]`. You might have two other r-band images taken at different times again. These would be initialized with `channels=[(‘r’,0)]` and `channels=[(‘r’,1’)]`. You may wish to take note of any epochs where the transient is known to be ‘off’ - you can add this constraint later if desired."
              - answer: "No"
                templates:
                  - replacement: code
                    code: "channels=[\"g\", \"r\", \"i\", \"z\", \"y\"]\n\n{{obs}}"
                commentary: "For each image, the channels in the image can be specified as a list of the filters"
          - question: Are your images at the same resolution
            answers:
              - answer: "Yes"
                followups:
                  - question: Are your images pre-aligned to the same wcs?
                    answers:
                      - answer: "Yes"
                      - answer: "No"
                        commentary: "If you find performance or memory issues for a large number of epochs, you might consider pre-aligning them with a tool such as [SWarp](https://www.astromatic.net/software/swarp/) to improve modeling speed."
              - answer: "No"
        commentary: "We start with initializing the channels for the observation. The channels in the image can be specified as a list of the filters, like the above example."
  - question: Click to continue
    answers:
      - answer: Continue
        templates:
          - replacement: obs
            code: "obs = scarlet2.Observation(
            \n    jnp.array(data).astype(float),
            \n    weights=jnp.array(weight).astype(float),
            \n    psf=scarlet2.ArrayPSF(jnp.array(psf).astype(float)),
            \n    wcs=wcs,
            \n    channels=channels,
            \n)
            \n\n{{frame}}"
          - replacement: imports
            code: "import jax.numpy as jnp\n{{imports}}"
        commentary: "Once you have specified channels for each observation, each one can be set up by initializing an `Observation` object."
  - question: Click to continue
    answers:
    - answer: Continue
      templates:
        - replacement: frame
          code: "model_frame = scarlet2.Frame.from_observations(
          \n    observations=obs,
          \n    coverage=\"union\",  # or \"intersection\"
          \n)
          \n
          \n{{plot}}"
      commentary: "The list of observations can then be supplied to create a `Frame`."
  - question: Click to continue
    answers:
      - answer: Continue
        templates:
          - replacement: plot
            code: "norm = scarlet2.plot.AsinhAutomaticNorm(obs)
            \nscarlet2.plot.observation(
            \n     obs, norm=norm, sky_coords=ra_dec, show_psf=True, label_kwargs={\"color\": \"red\"}
            \n)
            \n
            \n{{source_init}}"
        commentary: "The observations and PSF models can be plotted as above."
  - question: Do you have a position catalog of the sources in the image you wish to model?
    answers:
    - answer: No, I don't have positions
      templates:
        - replacement: source_init
          code: "# Run source detection to get positions
              \n
              \n{{source_init}}"
      commentary: "We recommend running [sep](https://sep.readthedocs.io/en/stable/) or another source detection algorithm on your images to find their positions for initialization."
    - answer: Yes, I have positions
      commentary: "Great, these positions will be used for source initialization."
  - switch: transient
    cases:
      - value: 0
        questions:
          - question: Click to continue
            answers:
              - answer: Continue
                templates:
                  - replacement: source_init
                    code: "bands = [\"g\", \"r\"]
                  \nband_selector = lambda channel: channel[0]
                  \nepoch_selector = lambda channel: channel[1]
                  \n
                  \n{{source_init}}"
                commentary: "Before initializing sources as ‘static’ or ‘variable’, we need to set up the ability to parse the filters and epochs of the channels. We can do that by defining the following. Let’s say our observations were given channels like (‘g’,0). Then we would set up the following like above."

  - question: Do you have any galaxies or extended sources to model?
    answers:
    - answer: "Yes"
      followups:
      - switch: transient
        cases:
        - value: 0
          questions:
          - question: Would you like to model galaxies with?
            variable: "galaxy_model"
            answers:
            - answer: flexible non-parametric morphology models (starlets)
              templates:
              - replacement: source_init
                code: "# 1) Host galaxy that is static across epochs
                      \ntry:
                      \n    spectrum, morph = scarlet2.init.from_gaussian_moments(obs, center, box_sizes=[15, 21])
                      \nexcept IndexError:
                      \n    morph = scarlet2.init.compact_morphology()
                      \n# the host is barely resolved and the data are noisy:
                      \n# use a starlet morphology for extra stability (esp to noise)
                      \nmorph = scarlet2.StarletMorphology.from_image(morph)
                      
                      \n# Select the transient-free epochs to initialize amplitudes for the static source
                      \n# These will be shared across all epochs. Make sure this matches the number of filters included in the modeling!
                      \nspectrum = spectrum[0:2]
                      
                      \nscarlet2.Source(
                      \n    center, scarlet2.StaticArraySpectrum(spectrum, bands=bands, band_selector=band_selector), morph
                      \n)
                      \n\n{{source_init}}"
              commentary: "Galaxies with starlet morphologies with a constant flux across epochs can be initialized as follows"
            - answer: non-parametric models guided by a prior for HSC or ZTF galaxies
              templates:
                - replacement: source_init
                  code: "with scarlet2.Scene(model_frame) as scene:
                      \n    for i, center in enumerate(ra_dec):
                      \n        try:
                      \n            spectrum, morph = init.from_gaussian_moments([obs_hst, obs_hsc], center, min_corr=0.99)
                      \n        except ValueError:
                      \n            spectrum = init.pixel_spectrum([obs_hst, obs_hsc], center)
                      \n    morph = init.compact_morphology()
                      \n      scarlet2.Source(center, spectrum, morph)
                      \n\n{{source_init}}"
                - replacement: imports
                  code: "import scarlet2.init as init\n{{imports}}"
            - answer: Sersic profiles?
              templates:
                - replacement: source_init
                  code: "# 1) Host galaxy that is static across epochs
                      \nspectrum = scarlet2.init.pixel_spectrum(obs_sc2, center)
                      \nsersic = scarlet2.SersicMorphology(
                      \n    ellipticity=jnp.asarray([0.2,-0.5]),        
                      \n    size=jnp.asarray(3.5),
                      \n    n=jnp.asarray(2.2),
                      \n)
                      \nscarlet2.Source(
                      \n    center,
                      \n    flux,
                      \n    sersic
                      \n)
                      \n
                      \n# Select the transient-free epochs to initialize amplitudes for the static source. 
                      \n# Make sure this matches the number of filters included in the modeling!
                      \n# These will be shared across all epochs
                      \nspectrum = spectrum[0:2]
                      \n
                      \nscarlet2.Source(
                      \n    center, scarlet2.StaticArraySpectrum(spectrum, bands=bands, band_selector=band_selector), sersic
                      \n)
                      \n
                      \n\n{{source_init}}"
        - value: null
          questions:
            - question: Would you like to model galaxies with?
              variable: "galaxy_model"
              answers:
                - answer: flexible non-parametric morphology models (starlets)
                  templates:
                    - replacement: source_init
                      code: "with scarlet2.Scene(model_frame) as scene:
                            \n    for i, center in enumerate(ra_dec):
                            \n        try:
                            \n            spectrum, morph = init.from_gaussian_moments([obs_hst, obs_hsc], center, min_corr=0.99)
                            \n        except ValueError:
                            \n            spectrum = init.pixel_spectrum([obs_hst, obs_hsc], center)
                            \nmorph = init.compact_morphology()
                            \n    morph = scarlet2.StarletMorphology.from_image(morph,
                            \n      scarlet2.Source(center, spectrum, morph)
                            \n)
                            \n\n{{source_init}}"
                    - replacement: imports
                      code: "import scarlet2.init as init\n{{imports}}"
                  commentary: "Galaxies with starlet morphologies can be initialized as follows"
                - answer: non-parametric models guided by a prior for HSC or ZTF galaxies
                  templates:
                    - replacement: source_init
                      code: "with scarlet2.Scene(model_frame) as scene:
                      \n    for i, center in enumerate(ra_dec):
                      \n        try:
                      \n            spectrum, morph = init.from_gaussian_moments([obs_hst, obs_hsc], center, min_corr=0.99)
                      \n        except ValueError:
                      \n            spectrum = init.pixel_spectrum([obs_hst, obs_hsc], center)
                      \nmorph = init.compact_morphology()
                      \n      scarlet2.Source(center, spectrum, morph)
                      \n)
                      \n\n{{source_init}}"
                    - replacement: imports
                      code: "import scarlet2.init as init\n{{imports}}"
                  commentary: "Galaxies with a morphology prior applied during parameter fitting can be initialized as follows"
                - answer: Sersic profiles?
                  templates:
                    - replacement: source_init
                      code: "# 1) Host galaxy that is static across epochs
                      \nspectrum = init.pixel_spectrum(obs_sc2, center)
                      \nsersic = scarlet2.SersicMorphology(
                      \n                                    ellipticity = jnp.asarray([0.2,-0.5]),        
                      \n                                    size= jnp.asarray(3.5),
                      \n                                    n=jnp.asarray(2.2),
                      \n                    )
                      \nscarlet2.Source(
                      \n    center, spectrum, sersic
                      \n)
                      \n
                      \n\n{{source_init}}"
                    - replacement: imports
                      code: "import scarlet2.init as init\n{{imports}}"

    - answer: "No"
  - question: Do you have any point sources to model?
    variable: "point_sources"
    answers:
    - answer: "Yes"
      followups:
      - question: Are any of the point sources transient or variable?
        answers:
        - answer: "Yes"
          commentary: "Variable point sources can be initialized as follows"
          templates:
          - replacement: source_init
            code: "# 2) Point source for the transient
                  \n# Define the epochs where the transient is allowed to have a non-zero amplitude (this could be all epochs)
                  \nepochs = [2, 3]
                  \n# As we already know that the transient is present, we can measure the flux at the center location
                  \n# Initializing as zero also works
                  \nspectrum = scarlet2.init.pixel_spectrum(obs, center)
                  \n 
                  \nscarlet2.PointSource(
                  \n    center, scarlet2.TransientArraySpectrum(spectrum, epochs=epochs, epoch_selector=epoch_selector)
                  \n)
                  \n\n{{source_init}}"
        - answer: "No"
          commentary: "Point sources can be initialized as follows"
          templates:
          - replacement: source_init
            code: "# 2) Point source for the transient
                  \n# Define the epochs where the transient is allowed to have a non-zero amplitude (this could be all epochs)
                  \nepochs = [2, 3]
                  \n# As we already know that the transient is present, we can measure the flux at the center location
                  \n# Initializing as zero also works
                  \nspectrum = scarlet2.init.pixel_spectrum(obs, center)
                  \n 
                  \nscarlet2.PointSource(
                  \n    center, scarlet2.TransientArraySpectrum(spectrum, epochs=epochs, epoch_selector=epoch_selector)
                  \n)
                  \n\n{{source_init}}"
    - answer: "No"
  - question: Click to continue
    answers:
    - answer: Continue
      templates:
        - replacement: source_init
          code: "print(scene.sources)
                \n\n{{parameters}}"
      commentary: "After initializing all sources, You can check the final list of sources as follows"
  - question: Click to continue
    answers:
    - answer: Continue
      templates:
        - replacement: parameters
          code: "pos_step = 1e-2
                \nmorph_step = lambda p: scarlet2.relative_step(p, factor=1e-3)
                \nSED_step = lambda p: scarlet2.relative_step(p, factor=5e-2)

                \nparameters = scene.make_parameters()
                \n\n{{parameters}}"
        - replacement: imports
          code: "from numpyro.distributions import constraints\n{{imports}}"
      commentary: "You can initialize parameters as follows"
  - switch: galaxy_model
    cases:
    - value: 0
      questions:
      - question: Click to continue
        answers:
        - answer: Continue
          commentary: "We set the parameters for the galaxy model."
          templates:
          - replacement: parameters
            code: "parameters += scarlet2.Parameter(
                  \n    scene.sources[0].spectrum.data, name=f\"spectrum.{0}\", constraint=constraints.positive, stepsize=SED_step
                  \n)
                  \nparameters += scarlet2.Parameter(
                  \n    scene.sources[0].morphology.coeffs,
                  \n    name=f\"morph.{0}\",
                  \n    stepsize=morph_step,
                  \n)
                  \n\n{{parameters}}"
    - value: 1
      questions:
        - question: Click to continue
          answers:
            - answer: Continue
              commentary: "We set the parameters for the galaxy model."
              templates:
                - replacement: parameters
                  code: "# instantiate the prior class
                        \ntemp = 2e-2  # values in the range of [1e-3, 1e-1] produce good results
                        \nprior32 = get_prior(\"hsc32\")
                        \nprior64 = get_prior(\"hsc64\")
                        \nprior32 = ScorePrior(prior32, prior32.shape(), t=temp)
                        \nprior64 = ScorePrior(prior64, prior64.shape(), t=temp)
                        \n
                        \nparameters += scarlet2.Parameter(
                        \n    scene.sources[0].spectrum.data, name=f\"spectrum.{0}\", constraint=constraints.positive, stepsize=SED_step
                        \n)
                        \n
                        \nprior = prior32 if max(scene.sources[i].morphology.shape) <= 32 else prior64
                        \nparameters += Parameter(
                        \n    scene.sources[i].morphology,
                        \n    name=f\"morph:{i}\",
                        \n    prior=prior,  # attach the prior here
                        \n    stepsize=morph_step,
                        \n)
                        \n\n{{parameters}}"
                - replacement: imports
                  code: "from galaxygrad import get_prior
                        \nfrom scarlet2.nn import ScorePrior\n{{imports}}"
    - value: 2
      questions:
        - question: Click to continue
          answers:
            - answer: Continue
              commentary: "We set the parameters for the galaxy model."
              templates:
                - replacement: parameters
                  code: "parameters += scarlet2.Parameter(scene3.sources[i].spectrum.data, name=f\"spectrum.{i}\", constraint=constraints.positive, stepsize=SED_step)    
                        \nparameters += scarlet2.Parameter(scene3.sources[i].center, name=f\"morph.center.{i}\", constraint=constraints.positive, stepsize=step)
                        \nparameters += scarlet2.Parameter(scene3.sources[i].morphology.ellipticity, name=f\"morph.ellipticity.{i}\", constraint=constraints.interval(-1,1), stepsize=step)
                        \nparameters += scarlet2.Parameter(scene3.sources[i].morphology.size, name=f\"morph.size.{i}\", constraint=constraints.interval(1.0,6.0), stepsize=step)
                        \nparameters += scarlet2.Parameter(scene3.sources[i].morphology.n, name=f\"morph.n.{i}\", constraint=constraints.interval(.5,10), stepsize=step)
                        \n\n{{parameters}}"
  - switch: point_sources
    cases:
    - value: 0
      questions:
      - question: Click to continue
        answers:
        - answer: Continue
          commentary: "We set the parameters for the point source model."
          templates:
          - replacement: parameters
            code: "parameters += scarlet2.Parameter(scene.sources[1].spectrum.data, name=f\"spectrum.{1}\", stepsize=SED_step)
                  \nparameters += scarlet2.Parameter(
                  \n    scene.sources[1].center, name=f\"center.{1}\", constraint=constraints.positive, stepsize=pos_step
                  \n)
                  \n\n{{parameters}}"
  - question: Click to continue
    answers:
    - answer: Continue
      commentary: "We can then fit the scene and inspect the result"
      templates:
        - replacement: parameters
          code: "stepnum = 1000
                \nscene_ = scene.fit(obs, parameters, max_iter=stepnum, e_rel=1e-4, progress_bar=False)
                \n# Plot the model, for each epoch
                \nscarlet2.plot.scene(
                \n    scene_,
                \n    observation=obs,
                \n    norm=norm,
                \n    show_model=True,
                \n    show_observed=True,
                \n    show_rendered=True,
                \n    show_residual=True,
                \n    add_labels=True,
                \n    add_boxes=True,
                \n    split_channels=False,
                \n    box_kwargs={\"edgecolor\": \"red\", \"facecolor\": \"none\"},
                \n    label_kwargs={\"color\": \"red\"},
                \n)
                \nplt.show()
                \n\n{{fit}}"
        - replacement: imports
          code: "import matplotlib.pyplot as plt\n{{imports}}"
  - question: Click to continue
    answers:
    - answer: Continue
      commentary: "We can extract the fitted parameter fluxes with syntax like this. Want to sample over the posteriors to get uncertainties on fitted parameters? [Check out the tutorial here.](https://scarlet2.readthedocs.io/en/latest/howto/sampling.html)"
      templates:
        - replacement: fit
          code: "print(\"----------------- {}\".format(channels))
                \nfor k, src in enumerate(scene_.sources):
                \n    print(\"Source {}, Fluxes: {}\".format(k, scarlet2.measure.flux(src)))
                \n\n{{end}}"